# dsa110_voltages
scripts and notebooks to process and visualize DSA110 voltage data


two scripts: 


1.  `pv`: A C program for dedispersion and data extraction from raw voltage files.
2.  `plotter.py`: A Python library for analyzing and visualizing the data products generated by `pv`.


`pv` is a command-line tool written in C designed for efficient processing of large-scale voltage data. It can perform dedispersion, median subtraction, and extract data in various formats.

### Why did take me so long to get it going? 

*   **Made it very complicated in the name of High Performance**: Optimized with SIMD and multi-threading using OpenMP.
*   **Multiple Output Modes**: Can generate dedispersed time series, dynamic spectra (stokes I waterfall plots), or raw complex voltage data.
*   **Time Slicing**: Allows processing of specific time or sample ranges.
*   **Automatic Path Handling**: Can automatically determine input and output paths based on a candidate name convention.

### Compilation

To compile `pv`.

```bash
gcc -o pv pv.c -lm -O3 -march=native -fopenmp 
```

optionally use `-ffast-math` to speed things up but its minimal. 

### Usage

The `pv` program has two main modes of operation: using a candidate name for automatic path discovery assumign using candidates from `/dataz/dsa110/candidates/<candidate>/Level2/voltages`  or specifying input/output directories manually. in case you did manual copies elsewhere. 

```
Usage: ./pv [MODE 1: -c <candidate>] [MODE 2: -i <input_dir> -o <output_dir>] -d <DM> [OPTIONS]

MODE 1 - Candidate name (automatic paths):
  -c <candidate>  Candidate name (auto-generates paths)
                  Input:  /dataz/dsa110/candidates/<candidate>/Level2/voltages
                  Output: <candidate>_out

MODE 2 - Manual paths:
  -i <input_dir>  Input directory containing voltage files
  -o <output_dir> Output directory for processed files

Required:
  -d <DM>         Dispersion measure in pc/cmÂ³

Options:
  -M              Enable median subtraction per frequency channel
  -t <threads>    Number of threads (0=auto-detect, default: auto)
  -T <max_threads> Maximum threads allowed (default: 35 for safety)

Output Modes:
  -P              Time series mode (default): sum across frequency channels
  -S              Spectra mode: save all frequency channels
  -R              Raw voltage mode: save complex voltages per polarization

Time Slicing (optional):
  -s <seconds>    Start time in seconds (default: 0.0)
  -e <seconds>    End time in seconds (default: process until end)
  -I <index>      Start sample index (overrides -s if specified)
  -J <index>      Stop sample index (overrides -e if specified)

Examples:
  # Process a candidate, generating a dedispersed time series
  ./pv -c 250914hbqw -d 24.6

  # Process a candidate, generating dynamic spectra
  ./pv -c 250914hbqw -d 24.6 -S

  # Process a time slice from 0.5s to 0.6s
  ./pv -c 250914hbqw -d 24.6 -s 0.5 -e 0.6

  # Process a sample slice using manual paths
  ./pv -i /path/to/voltages -o /path/to/output -d 24.6 -I 15000 -J 18000
```

## `plotter.py`: Analysis and Visualization

`plotter.py` is a Python library for analyzing and visualizing the data generated by `pv`. It provides classes to handle the different output formats and to create insightful plots.

### Dependencies



### Classes

The library contains three main analyzer classes:

*   **`TimeSeriesPlotter`**: For analyzing dedispersed time series data (`.dedisp` files). It can be used to plot SNR vs. time for individual or summed antennas.
*   **`DSA110WaterfallPlotter`**: For analyzing dynamic spectra data (`.spec` files). It can generate waterfall plots for individual antennas or an incoherent sum of multiple antennas.
*   **`DSA110RawVoltagePlotter`**: For analyzing raw complex voltage data (`.raw` files). It is memory-efficient and uses lazy loading to handle large raw voltage datasets.

### Example Usage

Here are some examples of how to use the plotter classes.

#### Analyzing a Dedispersed Time Series

```python
from plotter import TimeSeries

# Point to the directory containing the .dedisp files
output_dir = "250914hbqw_out/time_series"

# Create an analyzer instance
analyzer = TimeSeries(output_dir)

# Load data for all antennas
analyzer.load_all_data()

# Flag some antennas (e.g., known bad ones)
analyzer.add_flagged_antennas([10, 25])

# Plot the SNR of the summed unflagged antennas
analyzer.plot_snr_vs_time()

# Plot the SNR for a single antenna
analyzer.plot_snr_vs_time_ant(ant=5)
```

#### Plotting a Dynamic Spectrum (Waterfall)

```python
from plotter import Dynamic Spectra

# Point to the directory containing the .spec files
spectra_dir = "250914hbqw_out/spectra"

# Create a plotter instance
waterfall_plotter = DynamicSpectra(spectra_dir)

# Plot the waterfall for a single antenna
waterfall_plotter.plot_waterfall(antenna=15)

# Load all data, flag some antennas, and plot the incoherent sum
waterfall_plotter.load_all_data()
waterfall_plotter.add_flagged_antennas([10, 25])
waterfall_plotter.plot_incoherent_sum(freq_bin=4, time_bin=16)
```

#### Plotting Raw Voltage Data

```python
from plotter import RawVoltages

# Point to the directory containing the .raw files
raw_dir = "250914hbqw_out/raw_voltages"

# Create a plotter instance
raw_plotter = RawVoltagesraw_dir)

# Scan for metadata (does not load full data into memory)
raw_plotter.load_all_data()

# Plot the Stokes I waterfall for a single antenna
raw_plotter.plot_waterfall(antenna=7)

# Compute and plot the incoherent sum of unflagged antennas
raw_plotter.add_flagged_antennas([3, 12])
raw_plotter.plot_incoherent_sum(freq_bin=8, time_bin=32)
